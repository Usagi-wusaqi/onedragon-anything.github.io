---
lang: zh-CN
title: 基础-03-状态表达式
---

状态表达式 (`states`) 是一个字符串，用于判断当前游戏状态是否满足条件。它是处理器决策的核心。

```yaml
states: "[前台-击破]"
```

## 1. 基本语法

### 1.1. 单个状态

用 **中括号** 包围状态名称：

```yaml
states: "[前台-击破]"
```

在自动战斗过程中，脚本会持续识别各种状态。如果识别到 `前台-击破`，表达式结果为真，对应的操作就会执行。

完整可用状态见 [状态枚举](../reference/states_enum.md)。

### 1.2. 逻辑运算

使用 `&`（且）、`|`（或）、`!`（否）和 `()`（括号）组合多个状态：

```yaml
# 前台不是击破 且 后台第2个角色是击破
states: "![前台-击破] & [后台-1-击破]"
```

> `&` 和 `|` 没有运算优先级，用 `()` 来保证先后顺序。

<details>
<summary>更多例子</summary>

```yaml
# 识别到黄光且后台第二个是强攻
states: "[闪避识别-黄光] & [后台-2-强攻]"

# 刚连携换人，可以考虑爆发
states: "[按键-连携技-左] | [按键-连携技-右]"

# 复杂组合
states: "([状态A] | [状态B]) & ![状态C]"
```

</details>

## 2. 时间范围

每个状态都有一个**被识别到的时间**。默认情况下，`[状态名]` 等价于 `[状态名, 0, 1]`，表示"在最近 0~1 秒内识别到该状态"。

你可以自定义时间范围：

```yaml
# 最近 0~12 秒内按过连携技 → 粗略判断怪物失衡期
states: "[按键-连携技-左, 0, 12] | [按键-连携技-右, 0, 12]"
```

**格式**：`[状态名, 时间下限, 时间上限]`

- `时间下限, 时间上限` — 该状态距今多少秒内出现过
- 默认值 `0, 1` — 最近 1 秒内

## 3. 数值判断

部分状态带有数值，例如：

- `前台-能量` — 0~120
- `青衣-电压` — 0~100
- `朱鸢-子弹数` — 0~9

用 **大括号** 判断数值范围：

```yaml
# 子弹数在 7~9 之间，子弹快满了
states: "[朱鸢-子弹数]{7, 9}"

# 能量 ≥ 80 且终结技可用
states: "[前台-能量, 0, 999]{80, 999} & [按键可用-终结技]"

# 敌人数量等于 3
states: "[敌人数量, 0, 999]{3}"
```

**格式**：`[状态名, 时间下限, 时间上限]{值下限, 值上限}`

只传一个值 `{3}` 表示精确等于 3。

## 4. 自定义状态

以 `自定义-` 为前缀的状态是用户自定义的，可以通过 `设置状态` 指令创建，通过 `清除状态` 指令删除。

自定义状态的核心作用是让不同处理器之间进行"通信"。

### 4.1. 基本用法

```yaml
# 设置一个自定义状态
operations:
  - op_name: "设置状态"
    state: "自定义-连携次数"
    value: 1

# 在其他处理器中判断
handlers:
  - states: "[自定义-连携次数, 0, 3]{1, 2}"
    operations: ...
```

### 4.2. 连携计数器示例

利用自定义状态实现连携次数计数，控制每次连携选人的逻辑：

```yaml
# 第1次连携（状态不存在）→ 切强攻
- states: "![自定义-连携次数, 0, 3]"
  sub_handlers:
    - states: "[后台-2-强攻]"
      operations:
        - op_name: "按键-切换角色-上一个"
          post_delay: 0.5
        - op_name: "设置状态"
          state: "自定义-连携次数"
          value: 1

# 第2~3次连携 → 切支援
- states: "[自定义-连携次数, 0, 3]{1, 2}"
  sub_handlers:
    - states: "[后台-2-支援]"
      operations:
        - op_name: "按键-切换角色-上一个"
          post_delay: 0.5
        - op_name: "设置状态"
          state: "自定义-连携次数"
          value: 2
```

## 5. 高阶：倒计时机制

通过 `seconds` 的负数值，可以实现动态倒计时。

### 5.1. 核心机制

- **设置倒计时**：`seconds: -N` → 状态内部时间从 `-N` 开始，每秒向 `0` 趋近
- **延长倒计时**：`seconds_add: -M` → 为现有倒计时追加 `M` 秒
- **判断倒计时**：`[状态名, -N, 0]` → 检查倒计时是否仍在生效

### 5.2. 示例：失衡计时器

**目标**：敌人失衡时设置 12 秒输出窗口，每次攻击延长 1 秒。

```yaml
# 步骤 A: 敌人失衡 → 初始化12秒倒计时
handlers:
  - states: "[敌人-失衡, 0, 1]"
    operations:
      - op_name: "设置状态"
        state: "自定义-失衡计时"
        seconds: -12

# 步骤 B: 在连招中延长倒计时
operations:
  - op_name: "按键-普通攻击"
  - op_name: "设置状态"
    state: "自定义-失衡计时"
    seconds_add: -1

# 步骤 C: 根据倒计时做决策
handlers:
  - states: "[自定义-失衡计时, -99, 0]"
    operations:
      - operation_template: "强力追击连招"
```

## 6. 状态识别时间说明

不同状态的记录时间不同：

| 来源 | 识别时间 |
|---|---|
| 截图识别（闪光、角色、能量等） | 截图时间 |
| 脚本按键操作 | 按键结束时间（`post_delay` 之前） |
| 自定义状态 | `设置状态` 指令的参数时间 |

### 6.1. 时间判断的取舍

- **默认 `0, 1`**：保证及时性，只匹配最近 1 秒内的状态
- **自定义时间范围**：可以沿用较早的识别结果。例如 `[按键-连携技-左, 0, 12]` 表示最近 12 秒内连携过，可粗略判断失衡窗口
- 如果时间范围不当，可能导致使用过期的状态信息
